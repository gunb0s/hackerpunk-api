{"mappings":";;;;;;;;;;;ACAA;AAEA,MAAM,wCAAE;IAKN,YACE,MAAqB,EACrB,eAAuB,EACvB,GAA6B,CAC7B;QACA,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;QACvC,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,QAAQ,GAAG,IAAI,oBAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;KAC7E;IAED;;;KAGG,CACH,MAAM,oBAAoB,CAAC,MAAqB,EAAE;QAChD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;KAC/C;IAED;;KAEG,CACH,MAAM,IAAI,GAAG;QACX,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;KAC5B;IAED;;KAEG,CACH,MAAM,eAAe,CAAC,YAAoB,EAAE;QAC1C,MAAM,IAAI,CAAC,QAAQ,CAAC,eAAe,EAAE,CAAC;KACvC;IAED;;KAEG,CACH,MAAM,mBAAmB,CAAC,gBAAwB,EAAE;QAClD,MAAM,IAAI,CAAC,QAAQ,CAAC,mBAAmB,EAAE,CAAC;KAC3C;IAED;;KAEG,CACH,MAAM,UAAU,CAAC,SAAiB,EAAE;QAClC,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,CAAC;KAClC;IAED;;KAEG,CACH,MAAM,cAAc,CAAC,SAAiB,EAAE;QACtC,MAAM,IAAI,CAAC,QAAQ,CAAC,cAAc,EAAE,CAAC;KACtC;IAED;;KAEG,CACH,MAAM,mBAAmB,CAAC,UAAoB,EAAE;QAC9C,MAAM,IAAI,CAAC,QAAQ,CAAC,mBAAmB,EAAE,CAAC;KAC3C;IAED;;KAEG,CACH,MAAM,SAAS,CAAC,IAAY,EAAE;QAC5B,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;KACrC;CACF;;ADzED;AEEA,MAAM,yCAAG;CAAG;;;ACFZ;AAQO,MAAM,yCAAW,GAAG,CACzB,OAAe,EACf,QAAgB,EAChB,GAAW,GACuB;IAClC,IAAI,OAAO,KAAK,SAAS,EAAE,OAAO,oBAAM,CAAC,kBAAkB,EAAE,CAAC;IAE9D,IAAI,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,EACzD,OAAO,oBAAM,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;IAE5C,MAAM,OAAO,GAAG;QACd,CAAC,QAAQ,CAAC,EAAE,GAAG;KAChB,AAAC;IAEF,OAAO,oBAAM,CAAC,kBAAkB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;CACpD,AAAC;AAOK,MAAM,yCAAS,GAAG,CAAC,UAAkB,GAAoB;IAC9D,OAAO,IAAI,oBAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;CACtC,AAAC;AAQK,MAAM,yCAAS,GAAG,CACvB,MAAqB,EACrB,QAAuC,GACrB;IAClB,OAAO,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;CACjC,AAAC;;;AC7CF;AAEA;;;;GAIG,CACH,MAAM,yCAAY,GAAG,CAAC,GAAW,GAAmB;IAClD,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,GAAK;QACtC,IAAI,UAAU,GAAW,8BAAoB,CAAC,kBAAkB,EAAE,AAAC;QAEnE,8BAAoB,CAAC,WAAW,CAC9B;YACE,QAAQ,EAAE,GAAG;YACb,UAAU,EAAE,UAAU;YACtB,YAAY,EAAE,YAAY;SAC3B,EACD,CAAC,IAAG,EAAE,EAAE,GAAK;YACX,IAAI,IAAG,EAAE,MAAM,CAAC,IAAG,CAAC,CAAC;YACrB,EAAE,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,WAAW,GAAK;gBAC5C,IAAI,GAAG,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC;gBACrB,EAAE,CAAC,kBAAkB,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;gBAEtC,IAAI,OAAO,GAAG,EAAE,CAAC,YAAY,EAAE,CAAC,QAAQ,EAAE,AAAC;gBAC3C,IAAI,UAAU,GAAG,EAAE,CAAC,gBAAgB,CAAC,OAAO,EAAE,WAAW,CAAC,AAAC;gBAE3D,OAAO,CAAC;oBA1BlB,SA0BoB,OAAO;oBA1B3B,YA0B6B,UAAU;oBAAE,QAAQ,EAAE,UAAU;iBAAE,CAAC,CAAC;aACxD,CAAC,CAAC;SACJ,CACF,CAAC;KACH,CAAC,CAAC;CACJ,AAAC;","sources":["src/index.ts","lib/HP.ts","lib/HPA.ts","lib/provider.ts","lib/wallet.ts"],"sourcesContent":["import { HP } from \"../lib/HP\";\nimport { HPA } from \"../lib/HPA\";\nimport { setProvider } from \"../lib/provider\";\nimport { createWallet } from \"../lib/wallet\";\n\nexport { HP, HPA, setProvider, createWallet };\n","import { ethers } from \"ethers\";\n\nclass HP {\n  contract: ethers.Contract;\n  contractAddress: string;\n  abi: ethers.ContractInterface;\n\n  constructor(\n    signer: ethers.Signer,\n    contractAddress: string,\n    abi: ethers.ContractInterface\n  ) {\n    this.contractAddress = contractAddress;\n    this.abi = abi;\n    this.contract = new ethers.Contract(this.contractAddress, this.abi, signer);\n  }\n\n  /**\n   * @method change signer of contract\n   * @param signer\n   */\n  async changeContractSigner(signer: ethers.Signer) {\n    this.contract = this.contract.connect(signer);\n  }\n\n  /**\n   * @method initial minting once, only admin\n   */\n  async init() {\n    await this.contract.init();\n  }\n\n  /**\n   * @method set signup token reward, only admin\n   */\n  async setSignupReward(signupReward: number) {\n    await this.contract.setSignupReward();\n  }\n\n  /**\n   * @method set attendacne token reward, only admin\n   */\n  async setAttendanceReward(attendanceReward: number) {\n    await this.contract.setAttendanceReward();\n  }\n\n  /**\n   * @method mint token to reward signup, only minter\n   */\n  async signupMint(recipient: string) {\n    await this.contract.signupMint();\n  }\n\n  /**\n   * @method mint token to reward attendacne, only minter\n   */\n  async attendanceMint(recipient: string) {\n    await this.contract.attendacneMint();\n  }\n\n  /**\n   * @method mint token to reward users at once, only minter\n   */\n  async attendanceMintBatch(recipients: string[]) {\n    await this.contract.attendanceMintBatch();\n  }\n\n  /**\n   * @method check balance of user\n   */\n  async balanceOf(user: string) {\n    await this.contract.balanceOf(user);\n  }\n}\n\nexport { HP };\n","import { ethers } from \"ethers\";\n\nclass HPA {}\n\nexport { HPA };\n","import { ethers } from \"ethers\";\n\n/**\n * @param network default mainnet, can be url like http or wss\n * @param provider etherscan, infura, alchemy, etc...\n * @param key apikey, in case of infura project_id\n * @returns provider\n */\nexport const setProvider = (\n  network: string,\n  provider: string,\n  key: string\n): ethers.providers.BaseProvider => {\n  if (network === undefined) return ethers.getDefaultProvider();\n\n  if (network.startsWith(\"wss\") || network.startsWith(\"http\"))\n    return ethers.getDefaultProvider(network);\n\n  const options = {\n    [provider]: key,\n  };\n\n  return ethers.getDefaultProvider(network, options);\n};\n\n/**\n * @method make crypto wallet\n * @param privateKey string\n * @returns wallet\n */\nexport const setWallet = (privateKey: string): ethers.Wallet => {\n  return new ethers.Wallet(privateKey);\n};\n\n/**\n * @method connect provider to wallet\n * @param wallet\n * @param provider\n * @returns signer\n */\nexport const setSigner = (\n  wallet: ethers.Wallet,\n  provider: ethers.providers.BaseProvider\n): ethers.Signer => {\n  return wallet.connect(provider);\n};\n","import * as lightwallet from \"eth-lightwallet\";\n\n/**\n * @method: returns address and privateKey\n * @param {string} pwd user password\n * @return {Promise} object of address, privateKey and mnemonic\n */\nconst createWallet = (pwd: string): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    let secretSeed: string = lightwallet.keystore.generateRandomSeed();\n\n    lightwallet.keystore.createVault(\n      {\n        password: pwd,\n        seedPhrase: secretSeed,\n        hdPathString: \"m/0'/0'/0'\",\n      },\n      (err, ks) => {\n        if (err) reject(err);\n        ks.keyFromPassword(pwd, (err, pwDeriveKey) => {\n          if (err) reject(err);\n          ks.generateNewAddress(pwDeriveKey, 1);\n\n          let address = ks.getAddresses().toString();\n          let privateKey = ks.exportPrivateKey(address, pwDeriveKey);\n\n          resolve({ address, privateKey, mnemonic: secretSeed });\n        });\n      }\n    );\n  });\n};\n\nexport { createWallet };\n"],"names":[],"version":3,"file":"main.js.map"}