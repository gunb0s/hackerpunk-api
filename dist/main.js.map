{"mappings":"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","sources":["src/index.ts","lib/HP.ts","lib/HPA.ts","lib/provider.ts","lib/wallet.ts"],"sourcesContent":["import { HP } from \"../lib/HP\";\nimport { HPA } from \"../lib/HPA\";\nimport { setProvider } from \"../lib/provider\";\nimport { createWallet } from \"../lib/wallet\";\n\nexport { HP, HPA, setProvider, createWallet };\n","import { ethers } from \"ethers\";\n\n// const ca, abi\n\nclass HP {\n  provider: ethers.providers.BaseProvider;\n  wallet: ethers.Wallet;\n  signer: ethers.Signer;\n  contractSigner: ethers.Contract;\n  contractProvider: ethers.Contract;\n\n  // Temporary\n  contractAddress: string;\n  abi: ethers.ContractInterface;\n\n  constructor(\n    provider: ethers.providers.BaseProvider,\n    privateKey: ethers.utils.BytesLike,\n    contractAddress: string,\n    abi: ethers.ContractInterface\n  ) {\n    this.provider = provider;\n    this.wallet = new ethers.Wallet(privateKey);\n    this.signer = this.wallet.connect(this.provider);\n    this.contractAddress = contractAddress;\n    this.abi = abi;\n\n    this.contractSigner = new ethers.Contract(\n      this.contractAddress,\n      this.abi,\n      this.signer\n    );\n    this.contractProvider = new ethers.Contract(\n      this.contractAddress,\n      this.abi,\n      this.provider\n    );\n  }\n\n  /**\n   *\n   * @param address\n   * @returns\n   */\n  async balanceOf(address: string): Promise<any> {\n    const result = await this.contractProvider.balanceOf(address);\n    return result;\n  }\n\n  /**\n   * @param recipient token minted to\n   * @returns\n   */\n  async attendanceMint(recipient: string): Promise<any> {\n    const result = await this.contractSigner.attendanceMint(recipient);\n    return result;\n  }\n\n  /**\n   * @method mint at once, since tx fee\n   * @param recipients array token minted to\n   * @returns\n   */\n  async attendanceMintBatch(recipients: string[]): Promise<any> {\n    const result = await this.contractSigner.attendanceMintBatch(recipients);\n    return result;\n  }\n\n  /**\n   * @param donateRecord array of donate record: { from, to, amount }\n   * @returns\n   */\n  async donateBatch(donateRecord: object[]): Promise<any> {\n    const result = await this.contractSigner.donateBatch(donateRecord);\n    return result;\n  }\n}\n\nexport { HP };\n","import { ethers } from \"ethers\";\n\n// const ca, abi\n\nclass HPA {\n  provider: ethers.providers.BaseProvider;\n  wallet: ethers.Wallet;\n  signer: ethers.Signer;\n  contractSigner: ethers.Contract;\n  contractProvider: ethers.Contract;\n\n  // Temporary\n  contractAddress: string;\n  abi: ethers.ContractInterface;\n\n  constructor(\n    provider: ethers.providers.BaseProvider,\n    privateKey: ethers.utils.BytesLike,\n    contractAddress: string,\n    abi: ethers.ContractInterface\n  ) {\n    this.provider = provider;\n    this.wallet = new ethers.Wallet(privateKey);\n    this.signer = this.wallet.connect(this.provider);\n    this.contractAddress = contractAddress;\n    this.abi = abi;\n\n    this.contractSigner = new ethers.Contract(\n      this.contractAddress,\n      this.abi,\n      this.signer\n    );\n    this.contractProvider = new ethers.Contract(\n      this.contractAddress,\n      this.abi,\n      this.provider\n    );\n  }\n}\n\nexport { HPA };\n","import { ethers } from \"ethers\";\n\n/**\n * @param network default mainnet, can be url like http or wss\n * @param provider etherscan, infura, alchemy, etc...\n * @param key apikey, in case of infura project_id\n * @returns provider\n */\nexport const setProvider = (\n  network: string,\n  provider: string,\n  key: string\n): ethers.providers.BaseProvider => {\n  if (network === undefined) return ethers.getDefaultProvider();\n\n  if (network.startsWith(\"wss\") || network.startsWith(\"http\"))\n    return ethers.getDefaultProvider(network);\n\n  const options = {\n    [provider]: key,\n  };\n\n  return ethers.getDefaultProvider(network, options);\n};\n","import * as lightwallet from \"eth-lightwallet\";\n\n/**\n * @method: returns address and privateKey\n * @param {string} pwd user password\n * @return {Promise} object of address, privateKey and mnemonic\n */\nconst createWallet = (pwd: string): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    let secretSeed: string = lightwallet.keystore.generateRandomSeed();\n\n    lightwallet.keystore.createVault(\n      {\n        password: pwd,\n        seedPhrase: secretSeed,\n        hdPathString: \"m/0'/0'/0'\",\n      },\n      (err, ks) => {\n        if (err) reject(err);\n        ks.keyFromPassword(pwd, (err, pwDeriveKey) => {\n          if (err) reject(err);\n          ks.generateNewAddress(pwDeriveKey, 1);\n\n          let address = ks.getAddresses().toString();\n          let privateKey = ks.exportPrivateKey(address, pwDeriveKey);\n\n          resolve({ address, privateKey, mnemonic: secretSeed });\n        });\n      }\n    );\n  });\n};\n\nexport { createWallet };\n"],"names":[],"version":3,"file":"main.js.map"}